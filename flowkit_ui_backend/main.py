# This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
# If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

# coding: utf-8

"""
    FlowKitUI Backend

    A REST API for managing and postprocessing Flowkit data

    The version of the OpenAPI document: 1.3.0
    Generated by: https://openapi-generator.tech
"""


import os
import structlog
import asyncio
import aiomysql
from http import HTTPStatus
from fastapi import FastAPI, Request
from fastapi.exceptions import (
    RequestValidationError,
    HTTPException as StarletteHTTPException,
)
from fastapi.exception_handlers import (
    http_exception_handler,
    request_validation_exception_handler,
)
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.gzip import GZipMiddleware
from asgi_correlation_id import CorrelationIdMiddleware
from timing_asgi import TimingMiddleware, TimingClient
from timing_asgi.integrations import StarletteScopeToName
from flowkit_ui_backend.util import logging, gzip
from flowkit_ui_backend.db import db

default_log_level = "DEBUG" if (int(os.getenv("DEV_MODE", 0)) == 1) else "WARNING"
log_level = os.getenv("LOG_LEVEL", default_log_level)
log_level = log_level.upper()
logging.setup_logging(log_level=log_level, dev_mode=int(os.getenv("DEV_MODE", 0)) == 1)
logger = structlog.get_logger("flowkit_ui_backend.log")
logger.debug(
    f"Using log level {log_level} (default: {default_log_level}, dev mode: {bool(os.getenv('DEV_MODE', 0))})"
)


from flowkit_ui_backend.apis.accounts_api import router as AccountsApiRouter
from flowkit_ui_backend.apis.data_api import router as DataApiRouter
from flowkit_ui_backend.apis.general_api import router as GeneralApiRouter
from flowkit_ui_backend.apis.maintenance_api import router as MaintenanceApiRouter


class LogTimings(TimingClient):
    def timing(self, metric_name, timing, tags):
        logger.debug("Timing", metric_name=metric_name, timing=timing, tags=tags)


logger.debug(f"Starting {os.environ['APP_NAME']}...")
app = FastAPI(
    title="FlowKitUI Backend",
    description="A REST API for managing and postprocessing Flowkit data",
    version="1.3.0",
    openapi_url=f"/{os.environ['API_VERSION_URL_APPENDIX']}openapi.json",
)

app.add_middleware(
    TimingMiddleware,
    client=LogTimings(),
    metric_namer=StarletteScopeToName(prefix="FlowKitUI Backend", starlette_app=app),
)

app.add_middleware(CorrelationIdMiddleware)
logger.debug("Added correlation id middleware")

logger.debug("Adding CORS middleware...")
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        os.environ["FLOWKIT_UI_URL"],
        f"http://localhost:{os.environ['JUPYTER_PORT']}",
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

logger.debug("Adding GZip middleware...")
app.add_middleware(GZipMiddleware)


@app.exception_handler(NotImplementedError)
async def not_implemented_exception_handler(request: Request, e: NotImplementedError):
    return JSONResponse(status_code=HTTPStatus.NOT_IMPLEMENTED, content=str(e))


@app.exception_handler(PermissionError)
async def permission_exception_handler(request: Request, e: PermissionError):
    return JSONResponse(status_code=HTTPStatus.UNAUTHORIZED, content=str(e))


@app.exception_handler(StarletteHTTPException)
async def http_exception_handler(request, e:StarletteHTTPException):
    logger.error(f"{type(e)}: {str(e)}")
    if e.status_code == HTTPStatus.UNAUTHORIZED:
        # Idk why this is getting thrown for unauthorised instead of the above
        return await permission_exception_handler(request, e)
    return JSONResponse(status_code=e.status_code, content="Error")


@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request, e:RequestValidationError):
    logger.error(f"{type(e)}: {str(e)}")
    return JSONResponse(status_code=HTTPStatus.BAD_REQUEST, content="Bad or malformed request")


@app.on_event("startup")
async def _startup():
    logger.debug("Adding gzip support for requests...")
    app.router.route_class = gzip.GzipRoute

    logger.debug("Setting up routing...")
    app.include_router(AccountsApiRouter, prefix=os.environ["API_VERSION_URL_APPENDIX"])
    app.include_router(DataApiRouter, prefix=os.environ["API_VERSION_URL_APPENDIX"])
    app.include_router(GeneralApiRouter, prefix=os.environ["API_VERSION_URL_APPENDIX"])
    app.include_router(
        MaintenanceApiRouter, prefix=os.environ["API_VERSION_URL_APPENDIX"]
    )

    logger.debug("Creating db connection pool...")
    app.state.pool = await aiomysql.create_pool(
        host=os.environ["CONTAINER_NAME_DB"],
        port=int(os.environ["DB_PORT_CONTAINER"]),
        user=os.environ["DB_USER"],
        password=os.environ["DB_PW"],
        db=os.environ["DB_NAME"],
        loop=asyncio.get_event_loop(),
        autocommit=True,
        local_infile=True,
        minsize=1,
        maxsize=100,
    )
    logger.debug("Done.")

    logger.info(
        f"Check the server is running on http://localhost:{os.environ['SERVER_PORT_HOST']}/{os.environ['API_VERSION_URL_APPENDIX']}/heartbeat"
    )

    if os.environ["JUPYTER_ENABLED"] == "1":
        logger.info(
            f"Jupyter lab running on http://localhost:{os.environ['JUPYTER_PORT']}/lab?token=jupyter"
        )


@app.on_event("shutdown")
async def _shutdown():
    logger.debug("Shutting down db connection pool...")
    app.state.pool.close()
    await app.state.pool.wait_closed()
    logger.debug("Done.")
