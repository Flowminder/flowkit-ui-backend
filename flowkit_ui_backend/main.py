# This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
# If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

# coding: utf-8

"""
FlowKitUI Backend

A REST API for managing and postprocessing Flowkit data

The version of the OpenAPI document: 1.3.0
Generated by: https://openapi-generator.tech
"""


import os
from functools import lru_cache
from typing import Annotated

import structlog
import asyncio
import aiomysql
from http import HTTPStatus
from fastapi import FastAPI, Request, Depends
from fastapi.exceptions import (
    RequestValidationError,
    HTTPException as StarletteHTTPException,
)
from fastapi.exception_handlers import (
    http_exception_handler,
    request_validation_exception_handler,
)
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.gzip import GZipMiddleware
from asgi_correlation_id import CorrelationIdMiddleware
from timing_asgi import TimingMiddleware, TimingClient
from timing_asgi.integrations import StarletteScopeToName
from flowkit_ui_backend.util import gzip
from flowkit_ui_backend.util.config import Settings, get_settings
from flowkit_ui_backend.apis.accounts_api import router as AccountsApiRouter
from flowkit_ui_backend.apis.data_api import router as DataApiRouter
from flowkit_ui_backend.apis.general_api import router as GeneralApiRouter
from flowkit_ui_backend.apis.maintenance_api import router as MaintenanceApiRouter

logger = structlog.get_logger("flowkit_ui_backend.log")


class LogTimings(TimingClient):
    def timing(self, metric_name, timing, tags):
        logger.debug("Timing", metric_name=metric_name, timing=timing, tags=tags)


logger.debug(f"Starting {get_settings().app_name}...")
app = FastAPI(
    title="FlowKitUI Backend",
    description="A REST API for managing and postprocessing Flowkit data",
    version="1.3.0",
    openapi_url=f"/{get_settings().api_version_url_appendix}openapi.json",
)

app.add_middleware(
    TimingMiddleware,
    client=LogTimings(),
    metric_namer=StarletteScopeToName(prefix="FlowKitUI Backend", starlette_app=app),
)

app.add_middleware(CorrelationIdMiddleware)
logger.debug("Added correlation id middleware")

logger.debug("Adding CORS middleware...")
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        get_settings().flowkit_ui_url,
        f"http://localhost:{get_settings().jupyter_port}",
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

logger.debug("Adding GZip middleware...")
app.add_middleware(GZipMiddleware)


@app.exception_handler(NotImplementedError)
async def not_implemented_exception_handler(request: Request, e: NotImplementedError):
    return JSONResponse(status_code=HTTPStatus.NOT_IMPLEMENTED, content=str(e))


@app.exception_handler(PermissionError)
async def permission_exception_handler(request: Request, e: PermissionError):
    return JSONResponse(status_code=HTTPStatus.UNAUTHORIZED, content=str(e))


@app.exception_handler(StarletteHTTPException)
async def http_exception_handler(request, e):
    logger.error(f"{type(e)}: {str(e)}")
    return await http_exception_handler(request, e)


@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request, e):
    logger.error(f"{type(e)}: {str(e)}")
    return await request_validation_exception_handler(request, e)


@app.on_event("startup")
async def _startup(settings: Annotated[Settings, Depends(get_settings)]):
    logger.debug("Adding gzip support for requests...")
    app.router.route_class = gzip.GzipRoute

    logger.debug("Setting up routing...")
    app.include_router(AccountsApiRouter, prefix=settings.api_version_url_appendix)
    app.include_router(DataApiRouter, prefix=settings.api_version_url_appendix)
    app.include_router(GeneralApiRouter, prefix=settings.api_version_url_appendix)
    app.include_router(MaintenanceApiRouter, prefix=settings.api_version_url_appendix)

    logger.debug("Creating db connection pool...")
    app.state.pool = await aiomysql.create_pool(
        host=settings.container_name_db,
        port=settings.db_port_container,
        user=settings.db_user,
        password=settings.db_pw.get_secret_value(),
        db=settings.db_name,
        loop=asyncio.get_event_loop(),
        autocommit=True,
        local_infile=True,
        minsize=1,
        maxsize=100,
    )
    logger.debug("Done.")

    logger.info(
        f"Check the server is running on http://localhost:{settings.server_port_host}/{settings.api_version_url_appendix}/heartbeat"
    )

    if settings.jupyter_enabled == 1:
        logger.info(
            f"Jupyter lab running on http://localhost:{settings.jupyter_port}/lab?token=jupyter"
        )


@app.on_event("shutdown")
async def _shutdown():
    logger.debug("Shutting down db connection pool...")
    app.state.pool.close()
    await app.state.pool.wait_closed()
    logger.debug("Done.")
